# 什么是数组

什么是数组？数组（Array）是一种**线性表**数据结构。它用一组连续的内存空间，来存储一组具有相同数据类型的数据。

线性表（Linear List）就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈等也是线性表结构。

![img](assets/b6b71ec46935130dff5c4b62cf273477.jpg)

而与它相对立的概念是非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。

![img](assets/6ebf42641b5f98f912d36f6bf86f6569.jpg)

数组和链表的区别？链表适合插入、删除，时间复杂度 O(1)；数组支持**随机访问**，根据下标随机访问的时间复杂度为 O(1)。

# 低效的“插入”和“删除”

数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效。

数组插入操作最好时间复杂度 O(1)、最坏 O(n)、平均 O(n)，是因为插入会导致**大规模的数据搬移**。如果要将摸个数组插入到第 k 个位置，为了避免大规模的数据搬移，我们可以直接将第 k 位的数据搬移道数组元素的最后，把新的元素直接放入第 k 个位置。

删除操作和插入类似，最好时间复杂度位 O(1)、最坏 O(n)、平均 O(n)。为了提高删除效率，可以将多次删除集中在一起。记录下已经删除的数据，每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除，当数组没有更多空间存储数据时，再触发一次真正的删除操作。即 JVM 标记清除垃圾回收算法的核心思想。

# 警惕数组的访问越界

```c++
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}

```

数组 a[3] 访问越界，可能会导致代码无限循环。为什么？（复制几条留言的分析）

> 函数体内的局部变量存在栈上，且是连续压栈。在Linux进程的内存布局中，栈区在高地址空间，从高向低增长。变量i和arr在相邻地址，且i比arr的地址大，所以arr越界正好访问到i。当然，前提是i和arr元素同类型，否则那段代码仍是未决行为。

> 对于数组访问越界造成无限循环，我理解是编译器的问题，对于不同的编译器，在内存分配时，会按照内存地址递增或递减的方式进行分配。老师的程序，如果是内存地址递减的方式，就会造成无限循环。

> 如果用来编译这段程序的编译器按照内存地址递减的方式给变量分配内存，那么内存中的i将会被置为0，则为死循环永远出不去。

> 例子中死循环的问题跟编译器分配内存和字节对齐有关 数组3个元素加上一个变量a。4个整数刚好能满足8字节对齐 所以i的地址恰好跟着a2后面导致死循环。如果数组本身有4个元素 则这里不会出现死循环。因为编译器64位操作系统下 默认会进行8字节对齐变量i的地址就不紧跟着数组后面了。

# 容器能否完全替代数组？

ArrayList 最大的优势就是可以将很多数组操作的细节封装起来，以及动态扩容。如果使用 ArrayList，我们就完全不需要关心底层的扩容逻辑，ArrayList 已经帮我们实现好了。每次存储空间不够的时候，它都会讲空间自动扩容为1.5倍大小。

这里需要注意一点，因为扩容操作涉及内存申请和数据搬移，是比较耗时的。

不过，有些时候，用数组更合适些。

1. Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。
2. 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。
3. 还有一个是个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如 `Object[][] array`；而用容器的话则需要这样定义：`ArrayList<ArrayList> array`。

# 课后思考

1. 二维数组内存寻址：

   对于 m * n 的数组，a \[ i \]\[ j \] (i < m,j < n)的地址为：

   address = base_address + ( i * n + j) * type_size

2. JVM标记清除算法：

   大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。

   不足：1.效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效。2.空间问题。会产生不连续的内存空间碎片。  